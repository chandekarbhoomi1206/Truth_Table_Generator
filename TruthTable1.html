<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Truth Table Generator</title>
  <style>
    body {
      background-color: #101d2c;
      color: #e5e7eb;
      font-family: 'Arial', sans-serif;
      padding: 20px;
    }
    h1 {
      text-align: center;
      color: #3b82f6;
    }
    input, textarea, button {
      margin: 6px 0;
      padding: 10px;
      width: 100%;
      font-size: 1rem;
      background-color: #111827;
      border: 1px solid #4b5563;
      color: #e5e7eb;
    }
    button {
      background-color: #3b82f6;
      color: #1f2937;
      cursor: pointer;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 25px;
      background-color: #111827;
    }
    th, td {
      border: 1px solid #4b5563;
      padding: 8px;
      text-align: center;
    }
    th {
      background-color: #374151;
    }
  </style>
</head>
<body>

<h1>Truth Table Generator</h1>

<div>
  <label>Variables (comma separated,  example : X,Y,Z):</label>
  <input id="variables" type="text">

  <label>Enter logical expression:</label>
  <textarea id="expression" rows="2"></textarea>

  <p><strong>Use:</strong> ! for NOT, && for AND, || for OR, -> for IMPLIES, <-> for BICONDITIONAL</p>

  <button onclick="createTruthTable()">Create Truth Table</button>
</div>

<div id="output"></div>

<script>
function createTruthTable() {
  const variablesInput = document.getElementById('variables').value.trim();
  const expressionInput = document.getElementById('expression').value.trim();
  const outputDiv = document.getElementById('output');
  
  if (!variablesInput || !expressionInput) {
    alert('Both fields are required!');
    return;
  }
  
  const variables = variablesInput.split(',').map(varName => varName.trim());
  const numVars = variables.length;
  const expressionsInsideParentheses = findSubExpressions(expressionInput);
  
  let tableHTML = '<table><thead><tr>';
  variables.forEach(variable => tableHTML += `<th>${variable}</th>`);
  expressionsInsideParentheses.forEach(subExpr => tableHTML += `<th>(${subExpr})</th>`);
  tableHTML += `<th>Final Result</th></tr></thead><tbody>`;

  const totalRows = Math.pow(2, numVars);
  for (let row = 0; row < totalRows; row++) {
    let rowData = {};
    tableHTML += '<tr>';
    
    // Filling in the values for variables
    variables.forEach((variable, idx) => {
      const value = (row >> (numVars - idx - 1)) & 1 ? true : false;
      rowData[variable] = value;
      tableHTML += `<td>${value}</td>`;
    });

    // Calculating results for sub-expressions
    let subExpressionResults = {};
    expressionsInsideParentheses.forEach(subExpr => {
      const result = evaluateExpression(subExpr, rowData, subExpressionResults);
      subExpressionResults[subExpr] = result;
      tableHTML += `<td>${result}</td>`;
    });

    // Evaluating the final expression
    const finalResult = evaluateExpression(expressionInput, rowData, subExpressionResults);
    tableHTML += `<td>${finalResult}</td></tr>`;
  }

  tableHTML += '</tbody></table>';
  outputDiv.innerHTML = tableHTML;
}

function findSubExpressions(expression) {
  expression = expression.replace(/\s+/g, '');
  const stack = [];
  const subExpressions = [];

  for (let i = 0; i < expression.length; i++) {
    if (expression[i] === '(') {
      stack.push(i);
    } else if (expression[i] === ')') {
      const startIdx = stack.pop();
      const insideExpr = expression.substring(startIdx + 1, i);
      if (!subExpressions.includes(insideExpr)) {
        subExpressions.push(insideExpr);
      }
    }
  }
  return subExpressions;
}

function evaluateExpression(expression, varValues, subResults) {
  expression = expression.replace(/\s+/g, '');

  // Replace sub-expressions
  for (let [subExpr, result] of Object.entries(subResults)) {
    expression = expression.replace('(' + subExpr + ')', result);
  }

  // Replace variables with their respective truth values
  for (let [variable, value] of Object.entries(varValues)) {
    expression = expression.replace(new RegExp('\\b' + variable + '\\b', 'g'), value);
  }

  // Replace logical symbols with their textual equivalents
  expression = expression.replace(/<->/g, '↔').replace(/->/g, '→');

  // Evaluate sub-expressions inside parentheses
  while (expression.includes('(')) {
    const closeIdx = expression.indexOf(')');
    const openIdx = expression.lastIndexOf('(', closeIdx);
    const subExpr = expression.substring(openIdx + 1, closeIdx);
    const evaluatedValue = computeValue(subExpr);
    expression = expression.substring(0, openIdx) + evaluatedValue + expression.substring(closeIdx + 1);
  }

  return computeValue(expression);
}

function computeValue(expression) {
  while (expression.includes('!')) {
    expression = expression.replace(/!true/g, 'false').replace(/!false/g, 'true');
  }

  while (expression.includes('&&')) {
    expression = expression.replace(/(true|false)&&((true|false))/g, (match, a, b) => a === 'true' && b === 'true' ? 'true' : 'false');
  }

  while (expression.includes('||')) {
    expression = expression.replace(/(true|false)\|\|((true|false))/g, (match, a, b) => a === 'true' || b === 'true' ? 'true' : 'false');
  }

  while (expression.includes('→')) {
    expression = expression.replace(/(true|false)→(true|false)/g, (match, a, b) => (!convertToBoolean(a) || convertToBoolean(b)) ? 'true' : 'false');
  }

  while (expression.includes('↔')) {
    expression = expression.replace(/(true|false)↔(true|false)/g, (match, a, b) => (convertToBoolean(a) === convertToBoolean(b)) ? 'true' : 'false');
  }

  return expression.trim() === 'true';
}

function convertToBoolean(value) {
  return value === 'true';
}
</script>

</body>
</html>
